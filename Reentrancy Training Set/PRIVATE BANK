pragma solidity ^0.4.19;

// This contract represents a simple private bank where users can deposit and withdraw ether
contract PrivateBank
{
    // A mapping to store the balance of each address
    mapping (address => uint) public balances;
    
    // Minimum deposit amount set to 1 ether
    uint public MinDeposit = 1 ether;
    
    // Reference to a Log contract to store transaction messages
    Log TransferLog;
    
    // Constructor to initialize the Log contract address
    function PrivateBank(address _log)
    {
        TransferLog = Log(_log);
    }
    
    // Function to deposit ether into the bank
    function Deposit()
    public
    payable
    {
        // Check if the deposited amount is greater than or equal to the minimum deposit
        if(msg.value >= MinDeposit)
        {
            // Increment the sender's balance by the deposited amount
            balances[msg.sender]+=msg.value;
            // Log the deposit event
            TransferLog.AddMessage(msg.sender,msg.value,"Deposit");
        }
    }
    
    // Function to withdraw ether from the bank
    function CashOut(uint _am)
    {
        // Check if the requested amount is less than or equal to the sender's balance
        if(_am<=balances[msg.sender])
        {            
            // Attempt to send the requested amount to the sender
            // <yes> <report> REENTRANCY
            if(msg.sender.call.value(_am)())
            {
                // If the call is successful, decrement the sender's balance
                balances[msg.sender]-=_am;
                // Log the cash out event
                TransferLog.AddMessage(msg.sender,_am,"CashOut");
            }
        }
    }
    
    // Fallback function to allow the contract to receive ether
    function() public payable{}    
}

// This contract represents a log to store transaction messages
contract Log 
{
    // Struct to store details of each message
    struct Message
    {
        address Sender;
        string  Data;
        uint Val;
        uint  Time;
    }
    
    // Array to store the history of messages
    Message[] public History;
    
    // Variable to store the last message
    Message LastMsg;
    
    // Function to add a new message to the log
    function AddMessage(address _adr,uint _val,string _data)
    public
    {
        LastMsg.Sender = _adr; // Set the sender address
        LastMsg.Time = now; // Set the current timestamp
        LastMsg.Val = _val; // Set the value
        LastMsg.Data = _data; // Set the data string
        History.push(LastMsg); // Push the message to the history array
    }
}
Vulnerability: What it is: In the CashOut function, the contract first sends ether to msg.sender using msg.sender.call.value(_am)(). 
This low-level call transfers ether and forwards all remaining gas to the recipient, allowing them to execute further code, including calling back into the CashOut function before the original call completes.

Reentrancy Attack: If msg.sender is a contract with a fallback function that calls back into the CashOut function before the balance is updated (step 3), it can repeatedly withdraw funds, draining the contractâ€™s balance. This happens because the balance is only updated after the ether is sent, 
allowing the reentrant call to occur before the balance is reduced.

Safer Alternative: 
function CashOut(uint _am) public {
    // Check if the requested amount is less than or equal to the sender's balance
    if (_am <= balances[msg.sender]) {
        balances[msg.sender] -= _am; // Update state first to prevent reentrancy
        TransferLog.AddMessage(msg.sender, _am, "CashOut"); // Log the cash out event
        if (!msg.sender.send(_am)) { // Use `send` instead of `call`
            balances[msg.sender] += _am; // Revert state if send fails
        }
    }
}
In this alternative:

The sender's balance is decremented before attempting to send the ether.
send is used instead of call, which forwards only 2300 gas, preventing reentrancy by not giving the called contract enough gas to call back into the CashOut function.
If send fails, the state is reverted by adding the amount back to the sender's balance.